import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform

import java.util.stream.Stream

buildscript {
    configurations.classpath {
        resolutionStrategy {
            // Fix https://github.com/jreleaser/jreleaser/issues/1643
            force 'org.eclipse.jgit:org.eclipse.jgit:5.13.0.202109080827-r'
        }
    }
}

plugins {
    id("io.github.gradle-nexus.publish-plugin") version "2.0.0"
    id 'org.gradlex.extra-java-module-info' version '1.9' apply false
    id("com.diffplug.spotless") version "6.25.0" apply false
}

allprojects { subproject ->
    apply plugin: 'org.gradlex.extra-java-module-info'
    extraJavaModuleInfo {
        failOnMissingModuleInfo.set(false)
    }
    apply from: "$rootDir/gradle/gradle_scripts/modules.gradle"
}

subprojects {subproject ->
    if (subproject.name == 'dist') {
        return
    }

    apply plugin: 'com.diffplug.spotless'
    spotless {
        java {
            palantirJavaFormat()
            trimTrailingWhitespace()
            endWithNewline()
            importOrder('io.xpipe', 'javafx', '', 'java', '\\#')
        }
    }
}


def user = project.hasProperty('sonatypeUsername') ? project.property('sonatypeUsername') : System.getenv('SONATYPE_USERNAME')
def pass = project.hasProperty('sonatypePassword') ? project.property('sonatypePassword') : System.getenv('SONATYPE_PASSWORD')

tasks.withType(GenerateModuleMetadata) {
    enabled = false
}

nexusPublishing  {
    repositories {
        sonatype  {
            nexusUrl.set(uri('https://s01.oss.sonatype.org/service/local/'))
            snapshotRepositoryUrl.set(uri('https://s01.oss.sonatype.org/content/repositories/snapshots/'))
            username = user
            password = pass
        }
    }
    useStaging = true
}

var devProps = file("$rootDir/app/dev.properties")
if (!devProps.exists()) {
    devProps.text = file("$rootDir/gradle/gradle_scripts/dev_default.properties").text
}

def getArchName() {
    var arch = System.getProperty("os.arch").toLowerCase(Locale.ROOT)
    if (arch == 'amd64' || arch == 'x86_64') {
        return 'x86_64'
    }

    if (arch == 'arm' || arch == 'aarch64') {
        return 'arm64'
    }

    if (arch == 'x86') {
        return 'x86'
    }

    return arch
}

def getPlatformName() {
    def currentOS = DefaultNativePlatform.currentOperatingSystem;
    def platform
    if (currentOS.isWindows()) {
        platform = 'windows'
    }  else if (currentOS.isMacOsX()) {
        platform = 'osx'
    } else {
        platform = 'linux'
    }
    return platform;
}

project.ext {
    ci = System.getenv('CI') != null
    os = org.gradle.internal.os.OperatingSystem.current()
    allExtensions = Stream.concat(Stream.of(project(':base')), Arrays.stream(file("$rootDir/ext").list())
            .filter(s -> file("$rootDir/ext/$s/build.gradle").exists())
            .filter(s -> !s.equals('base'))
            .map(l -> project(":$l"))).toList()
    fullVersion = file("$rootDir/private_files.txt").exists()
    arch = getArchName()
    privateExtensions = file("$rootDir/private_extensions.txt").exists() ? file("$rootDir/private_extensions.txt").readLines() : []
    isFullRelease = System.getenv('RELEASE') != null && Boolean.parseBoolean(System.getenv('RELEASE'))
    isStage = System.getenv('STAGE') != null && Boolean.parseBoolean(System.getenv('STAGE'))
    rawVersion = file('version').text.trim()
    versionString = rawVersion + (isFullRelease || isStage ? '' : '-SNAPSHOT')
    versionReleaseNumber = rawVersion.split('-').length == 2 ? Integer.parseInt(rawVersion.split('-')[1]) : 1
    canonicalVersionString = rawVersion.split('-').length == 2 ? rawVersion.split('-')[0] : rawVersion
    buildId = UUID.nameUUIDFromBytes(versionString.getBytes())
    obfuscate = true
    changelog = file("dist/changelogs/${canonicalVersionString}.md").exists() ? file("dist/changelogs/${canonicalVersionString}.md").text.trim() + '\n' : ""
    productName = isStage ? 'XPipe PTB' : 'XPipe'
    kebapProductName = isStage ? 'xpipe-ptb' : 'xpipe'
    flatcaseProductName = isStage ? 'xpipeptb' : 'xpipe'
    publisher = 'XPipe UG (haftungsbeschr√§nkt)'
    shortDescription = isStage ? 'XPipe PTB (Public Test Build)' : 'Your entire server infrastructure at your fingertips'
    longDescription = 'XPipe is a new type of shell connection hub and remote file manager that allows you to access your entire server infrastructure from your local machine. It works on top of your installed command-line programs that you normally use to connect and does not require any setup on your remote systems.'
    website = 'https://xpipe.io'
    sourceWebsite = isStage ? 'https://github.com/xpipe-io/xpipe-ptb' : 'https://github.com/xpipe-io/xpipe'
    authors = 'Christopher Schnick'
    javafxVersion = '24-ea+15'
    platformName = getPlatformName()
    languages = ["en", "nl", "es", "fr", "de", "it", "pt", "ru", "ja", "zh", "tr", "da", "id", "sv", "pl"]
    jvmRunArgs = [
            "--add-opens", "java.base/java.lang=io.xpipe.app",
            "--add-opens", "java.base/java.lang=io.xpipe.core",
            "--add-opens", "java.desktop/java.awt=io.xpipe.app",
            "--add-opens", "net.synedra.validatorfx/net.synedra.validatorfx=io.xpipe.app",
            "--add-opens", "java.base/java.nio.file=io.xpipe.app",
            "--add-exports", "javafx.graphics/com.sun.javafx.tk=io.xpipe.app",
            "--add-exports", "jdk.zipfs/jdk.nio.zipfs=io.xpipe.modulefs",
            "--add-opens", "javafx.graphics/com.sun.glass.ui=io.xpipe.app",
            "--add-opens", "javafx.graphics/javafx.stage=io.xpipe.app",
            "--add-opens", "javafx.graphics/com.sun.javafx.tk.quantum=io.xpipe.app",
            "-Xms256m",
            "-Xmx4g",
            "-Dio.xpipe.app.arch=$rootProject.arch",
            "-Dio.xpipe.app.languages=${String.join(",", languages)}",
            "-Dfile.encoding=UTF-8",
            "-Dvisualvm.display.name=XPipe",
            "-Djavafx.preloader=io.xpipe.app.core.AppPreloader",
            "-Djdk.virtualThreadScheduler.parallelism=8"
    ]
    if (org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        jvmRunArgs += ["-Dapple.awt.application.appearance=system"]
    }
    useBundledJavaFx = fullVersion
    useBundledJna = fullVersion
    announce = System.getenv('SKIP_ANNOUNCEMENT') == null || !Boolean.parseBoolean(System.getenv('SKIP_ANNOUNCEMENT'))
    changelogFile = file("$rootDir/dist/changelogs/${versionString}.md").exists() ?
            file("$rootDir/dist/changelogs/${versionString}.md") :
            file("$rootDir/dist/changelogs/${canonicalVersionString}.md")
    incrementalChangelogFile = file("$rootDir/dist/changelogs/${canonicalVersionString}_incremental.md")
    signingKeyId = project.hasProperty('signingKeyId') ? project.property("signingKeyId") : System.getenv('GPG_KEY_ID')
    signingKey = project.hasProperty('signingKeyFile') ? file(project.property("signingKeyFile")).text : System.getenv('GPG_KEY')
    signingPassword = project.hasProperty('signingKeyPassword') ? project.property("signingKeyPassword") : System.getenv('GPG_KEY_PASSWORD')
    if (signingPassword == null) {
        signingPassword = ''
    }
    deeplApiKey = findProperty('DEEPL_API_KEY')
    customJavaFxPath = null
    bundleCds = ci && fullVersion
}

if (org.gradle.internal.os.OperatingSystem.current() == org.gradle.internal.os.OperatingSystem.LINUX) {
    jvmRunArgs.addAll("--add-opens", "java.desktop/sun.awt.X11=io.xpipe.app")
}
if (org.gradle.internal.os.OperatingSystem.current() == org.gradle.internal.os.OperatingSystem.MAC_OS) {
    jvmRunArgs.addAll("--add-exports", "java.desktop/com.apple.eawt=io.xpipe.app")
}

if (isFullRelease && rawVersion.contains("-")) {
    throw new IllegalArgumentException("Releases must have canonical versions")
}


if (isStage && !rawVersion.contains("-")) {
    throw new IllegalArgumentException("Stage releases must have release numbers")
}

def replaceVariablesInFileAsString(String f, Map<String, String> replacements) {
    def fileName = file(f).getName()
    def text = file(f).text
    def replaced = text.replace(replacements)
    return replaced
}

def replaceVariablesInFile(String f, Map<String, String> replacements) {
    def fileName = file(f).getName()
    def text = file(f).text
    def replaced = text.replace(replacements)
    def build = "${project.layout.buildDirectory.get()}/${UUID.randomUUID()}"
    file(build).mkdirs()
    def temp = "$build/$fileName"
    file(temp).text = replaced
    return file(temp)
}

def testTasks = [
        project(':core').getTasksByName('test', true),
        project(':app').getTasksByName('test', true),
        project(':base').getTasksByName('localTest', true),
        project(':proc').getTasksByName('localTest', true),
]


if (file("cli").exists()) {
    testTasks += [project(':cli').getTasksByName('remoteTest', true)]
}

tasks.register('testReport', TestReport) {
    getDestinationDirectory().set(file("$rootProject.buildDir/reports/all"))
    getTestResults().from(testTasks.stream().filter {!it.isEmpty()}.map {
        file("${it.project.buildDir.get(0)}/test-results/${it.name.get(0)}/binary")
    }.toList())
}

task testAll(type: DefaultTask) {
    for (final def t in testTasks) {
        t.forEach {dependsOn(it.getTaskDependencies())}
    }
    doFirst {
        for (final def t in testTasks) {
            t.forEach {it.executeTests()}
        }
    }
    finalizedBy(testReport)
}

group = 'io.xpipe'
version = versionString